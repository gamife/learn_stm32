- [定时器中断结构图](#定时器中断结构图)
- [定时器中断代码初始化顺序](#定时器中断代码初始化顺序)
- [AFIO重映射引脚](#afio重映射引脚)
- [定时器输出PWM](#定时器输出pwm)

### 定时器中断结构图
![images](images/image.png)
### 定时器中断代码初始化顺序
现在假设使用外部时钟, 详情见 system/Timer.c:
1. 通过GPIO接入外部时钟, 初始化GPIO的RCC及引脚
2. 使用定时器, 先初始化RCC_APB1PeriphClockCmd
3. 配置使用外部时钟还是内部时钟
4. 配置时基单元, 包括预分频PSC, 自动重装ARR
5. 使能TIM中断, TIM_ITConfig()
6. 配置NVIC, 使能TIM2_IRQn时钟类型的中断
7. 使能定时器, TIM_Cmd()
8. 编写中断函数TIM2_IRQHandler()


### AFIO重映射引脚
使用函数GPIO_PinRemapConfig()

### 定时器输出PWM
内部时钟, 经过预分频PSC, 然后CNT计数器开始计数, 每次计数到ARR(自动重装载寄存器), 就会重新从0开始计数(向上计数模式, 还有比如递减的).
为什么可以输出PWM波形, 是因为还有一个捕获比较寄存器CCR, CNT每次都会与CCR比较, 基于不同的模式, 比如当CNT小于CCR, 则输出高电平, 否则输出低电平, 当CNT到达ARR就是下一周期开始.
所以: (PSC和ARR记得代码填参数-1, 因为0就是一倍频)
* PWM频率= 72MHz/PSC/ARR
* PWM分辨率= 1/ARR 也就是占空比最小可以调节多少, 比如占空比一次最小增加 0.1%, 那么分辨率就是 0.1%, 那么ARR必须等于1000.
* PWM占空比= CCR/ARR 通过调节CCR的值, 可以动态调整占空比



